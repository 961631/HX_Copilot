




C# コーディング規約
Ver 1.2











はじめに	3
1.	フォーマット	4
1-1.	スペース	4
1-2.	インデント	5
1-3.	空行	5
1-4.	改行	6
1-5.	{}	7
1-6.	ファイル分け	7
2.	宣言	8
2.1.	変数	8
2.1.1.	共通規則	8
2.1.2.	ローカル変数	8
2.1.3.	メンバ変数	8
2.1.4.	定数	8
2.1.5.	型別プレフィックス一覧	9
2.2.	プロパティ	11
2.3.	メソッド	11
2.4.	クラス	11
2.5.	インタフェース	12
2.6.	ネームスペース	12
2.7.	列挙体	12
3.	禁止事項	12
3.1.	public メンバフィールドの禁止	12
3.2.	アクセス修飾子なしの宣言の禁止	13
3.3.	コピー、ペーストの禁止	14
3.4.	コードのコメントアウトの禁止	14
4.	例外処理	14
4.1.	例外とは	14
4.2.	例外処理の構文	15
4.3.	例外捕捉の原則	16
4.4.	例外処理における禁止事項	16
5.	Disposeメソッド	20
5.1.	マネージリソースとアンマネージリソース	20
5.2.	ガベージコレクタの動作	20
5.3.	IDisposable インタフェース	20
5.4.	using ステートメント	23

更新履歴説明2006/10/26Ver1.0作成。0.8 から、誤字脱字、誤変換を修正。Dispose 関連の説明が不十分だったものを修正。脚注を追加。2007/12/17Ver1.1 作成。全面改訂2008/02/14Ver1.2 作成。1.1 時点で 1.0 のコーディングスタイルを引きずっていた部分を修正。

はじめに
  C# とは Microsoft が提供する .NET Framework 上で動作する広範なアプリケーションを構築するようにデザインされた新しいプログラミング言語である。C# は C、C++ を基に、より強力なオブジェクト指向プログラミング言語としてデザインされている。
  本ドキュメントは C# で実装を行う上でのコーディング規約である。

1. フォーマット
  本章では C# でコーディングを行う上での記述フォーマットを示す。
1-1. スペース
  スペースは全て半角スペースとして扱う。全角スペースは使用しない。以下、ルールを示す。
* 演算子の前後
演算子の前後には基本的にスペースを入れる。ただし、インクリメント演算子（"++"）、デクリメント演算子（"--"）は例外とする。以下、例を示す。

* コメントの // の直後
コメント行を示す "//" の直後には必ずスペースを入れる。

* コメントの半角英数字と全角文字の境界
コメント内で半角英数字と全角文字が混在する場合には、半角英数字の前後にスペースを入れる。

* 条件式、ループ式などの"(" の直前
条件式、ループ式などにおいて、条件をくくる "(" の直前にスペースを入れる。

* "," の後
メソッド宣言の引数リスト、配列の初期化、メソッド呼び出し時の引数など、"," 区切りを行う際には、必ず "," の後にスペースを入れる。


1-2. インデント
  インデントはタブ（Tab）キーを使用してつける。なお、タブ幅はVisualStudio.NET の既定値である、半角スペース４つ分を使用する。

1-3. 空行
  メソッド内部での処理の切れ目などで、空行をうまく利用し可読性をあげる。以下に例を示す。


1-4. 改行
  C# は一つの式を複数の行に分けて記述することができる。式が長くなり横にスクロールさせなければ式全体が把握できないような場合には、可能な限り改行させて可読性を上げる。改行位置は処理の切れ目（メソッドの切れ目や引数の切れ目）で行う。また、改行した 2 行目以降は 1 行目よりインデントを一つ下げる。
  なお、このルールはメソッド宣言時の引数があまりにも多い場合、条件式が長い場合なども同様である。以下に例を示す。


1-5. {}
  C# では条件文や、プロパティ、クラス、インタフェース、ネームスペース、列挙体などのスコープに {} を使用する。この {} を宣言と同一行から始める書き方があるが、これは禁止する。必ず改行して記述すること。以下に例を示す。


1-6. ファイル分け
  ファイルは一つのファイルに複数のクラス、インタフェース、列挙体を記述せず、それぞれファイルとクラス、インタフェース、列挙体が1:1 になるように作成する。また、ファイル名はクラス名、インタフェース名、列挙体名と同じにすること。

2. 宣言
  本章では、変数、プロパティ、メソッドなどの宣言について記述する。
2.1. 変数
  変数には、ローカル変数、メンバ変数、定数の３種類がある。それぞれについて説明を行う。
2.1.1. 共通規則
  変数を宣言する際には、種類によらず共通規則にのっとって宣言する。すべての変数名は小文字からはじめ、単語の区切り部分で大文字にする。型プレフィックスは使用しない1が、型プレフィックスをつけなくてもわかるようになるべく具体的な変数名を使用する。以下に例を示す。


2.1.2. ローカル変数
  ローカル変数を宣言する際は、共通規則にのっとっていればよい。

2.1.3. メンバ変数
  メンバ変数を宣言する際には、ローカル変数と同様の命名規則により考えた変数名のプレフィックスに "_" を付与する。


2.1.4. 定数
  定数を宣言する場合には、その定数が何を示すかがすぐにわかるように全て大文字で記述する。以下に例を示す。

  
2.2. プロパティ
  プロパティ名はそのプロパティによって取得できるものが、そのクラスのどのような属性であるのかを明確にする名前付けを行い、必ず大文字で始める。例えば、社員をあらわす Employee クラスの氏名を示すプロパティであれば FullName という名前をつける。以下に例を示す。


  なお、プロパティの get アクセサと set アクセサに限り、{} を同一行内に記述することを許可する。これらのアクセサは比較的シンプルなコードになることが多く、また、クラスによっては数多くのプロパティを保持することがあるため、通常通り改行して {} を記述するとファイルが極端に縦長になることがあるためである。

2.3. メソッド
  メソッド名は動詞+名詞（GetUser、SetPasswordなど）の形式で名前付けを行う。その際、各単語の最初の文字を大文字にすること。

2.4. クラス
  クラス名は、ユーザ情報を示す UserInfo クラスなどのように、何のオブジェクトに対応するクラスであるのかが明確になるクラス名を付与し、必ず大文字で始める。

2.5. インタフェース
  インタフェース名もクラス名と同様、何のインタフェースを定義するものかを明確にする名前付けを行い、必ず大文字で始める。また .NET Framework の共通ルールとしてインタフェースの宣言にはプレフィックス I を付与することになっているため、本ドキュメントでもこのルールを適用する。

2.6. ネームスペース
  ネームスペースは通常プロジェクト単位で一意のものを使用する。Microsoft の推奨では、企業名、プロジェクト名、製品名などを "." 区切りで連結したものを使用することになっており、実際にそのようなネームスペース名を付与しているケースが多い。

2.7. 列挙体
  列挙体の宣言は、何を列挙するものなのか明確な名前付けを行い、サフィックスとして列挙体であることを意味する "Enum" を付与する。また、列挙子のそれぞれに対してコメントを付与するため、１行に１つの列挙子を記述する。以下に例を示す。


3. 禁止事項
  本章では C# でコーディングを行う際の禁止事項について記述する。
3.1. public メンバフィールドの禁止
  クラスを作成し、そのメンバ変数を作成する際に、アクセス修飾子を public にしてはいけない。同様に internal も避けるべきである。メンバフィールドは本来、クラスインスタンスの属性値を格納するために存在するものであり、他クラスから属性値や状態を書き換えられていいものではない。
  そのため、メンバフィールドに他クラスからアクセス可能にする場合には、そのフィールドに対応するプロパティを作成し、get アクセサを用意して参照のみ可能にするべきである。また、インタフェース上、公開および改変が可能であるべきフィールドについてもプロパティを作成し get、set の両アクセサを宣言するべきである。以下に例を示す。




3.2. アクセス修飾子なしの宣言の禁止
  クラス、フィールド、プロパティ、メソッドなど、何らかの宣言を行う際に、アクセス修飾子を指定せずに宣言をしてはいけない。アクセス修飾子を付与しないで宣言を行った場合、その宣言がどこで宣言された何であるかによってアクセシビリティレベルが変化する。そのため、アクセス修飾子なしでの宣言を行ってしまうと、アクセシビリティレベルが不明確になり、混乱を招くことになる。以下に例を示す。


3.3. コピー、ペーストの禁止
  一度書いた処理と同様の処理を別の部分で実装する必要が出てきた場合に、コピーペーストを使用してはいけない。ロジックをコピーすることにより、同じコードが複数の場所に散在することになり、コードの可読性が著しく悪化する。また、メンテナンスの際に、コピーしたコードの一箇所でバグが発見された場合など、複数の箇所を修正する必要が出てくる可能性がある。
  類似したロジックを記述した際には、継承やメソッドへの切り出しを利用して可能な限り類似したロジックが散在することのないように記述する。
  
3.4. コードのコメントアウトの禁止
  コード中にコメントアウトしたコードをそのまま残してはいけない。また、Debug 用などの自己確認用のためのコードなどを一時的に残す場合には、必ず「TODO : Debug用」などのコメントを残し、あとで削除する。
  リリースコードにコメントアウトされたコードが残っていると、それが本当は必要なのにコメントアウトされているのか、Debug 用でコメントアウトされているのかがわからなくなる。また、バージョンアップ時などに以前のバージョンのコードをコメントで残すようなことをすると、最新の処理がどれなのかわからなくなりコードの可読性が悪化する。以前のバージョンのコードを残す場合は、その時点でのソースコードをバックアップしておくべきであり、コードをコメントアウトするのは間違いである。
4. 例外処理
  本章では例外処理の記述ルールについて説明する。
4.1. 例外とは
  例外とは、.NET の世界ではアプリケーションやシステムに何らかの想定外の障害が発生したことを表現するものである。この「想定外の障害」とは、業務エラーとは明確に区別するべきものである。例えば、論理3階層（クライアント、APサーバ、DBサーバ）の構成を持つアプリケーションを設計・実装する際には、ネットワーク障害による DB アクセスの失敗などは予測はできても、業務的なエラーとはいえない。このようなものを「想定外の障害」と呼んでいる。

4.2. 例外処理の構文
　例外処理には try...catch...finally 構文を使用する。以下に例を示す。

  なお、この構文にはいくつか注意点がある。以下に記す。
① try ブロックでは 例外が発生する可能性のある場所のみを囲む
　余分な範囲を含めると、他の場所で発生した例外をも捕捉してしまう可能性がある
② catch ブロックでは正常処理フローに戻したい例外のみを指定する
　発生する可能性がある例外の中で、正常処理に戻したい例外以外も捕捉してしまわないように注意する。
③ catch ブロックは上から順に実行される
　catch ブロックは上から順に実行されるため、一番上に例外の既定クラス Exception を catch するコードを記述してはならない。

4.3. 例外捕捉の原則
  .NET の例外処理にはいくつかの原則がある。以下に記す。

* 例外は発生箇所での捕捉を行わず集約例外ハンドラ2で捕捉する。（例外あり）
　.NET においては全てのエラーが例外オブジェクトとなって、その上部構造（メソッドの呼び出し元など）に通知される。例外とは「想定外の障害」であるはずなので、発生元を障害発生前に特定しておくのは困難である。そのため、基本はアプリケーション全体の集約例外ハンドラで捕捉することになる。ただし、以下に述べるようにこの原則に当てはまらず、個別に処理すべきものもある。
　
* 捕捉する例外の条件
  例外処理の構文を用いて、個別に捕捉するべき例外とは、以下の条件を満たすものである。
A) その発生が十分予想されている
B) その際に行うべき対処方法が完全に明確化されている
C) 業務フロー的にみて、正常なフロールートに引き戻す必要がある場合
  例外処理の構文は、業務フローを調整するものとして使用する。その場合、上記3条件を満たさない例外を捕捉するとアプリケーションとして異常な値を入力されているのにもかかわらずそのまま処理が続行されてしまうなどの恐れもある。そのため、個別に例外を捕捉する場合には、十分な注意が必要である。

4.4. 例外処理における禁止事項
  以下、例外処理における禁止事項を記述する。
* throw ex; の禁止
  catch 句では catch した例外を再スローすることができる。その際、catch した例外オブジェクトを throw ex; としてスローした場合、例外の発生位置がリセットされてしまうため、これを禁止する。以下に例を示す。


  上記の例では CLR3 で定義されている XmlNode クラスの SelectSingleNode メソッドを呼びだし、そこで発生した例外を throw しているように見えるが、実際にはこのようにすると XPathException の発生元が GetNode メソッドで発生したように通知されてしまう。そのため、捕捉した例外を再スローするためには、以下のように記述する。


* catch (Exception ex) の禁止
  catch 句は catch する例外の種類を特定して、指定した例外の場合のみ処理をフローに戻す際に使用する。あらゆる .NET 定義の例外クラスは 全てSystem.Exception クラスから派生しており、catch (Exception) と記述すると全ての例外を catch してしまうことになる。この「全ての例外」の中には、StackOverflowException, OutOfMemoryException などといった、システムとして致命的な例外も含まれる。これらの例外は捕捉は可能だが、それ以降の復帰処理が正常に動く保証はなく（アプリケーション全体がダウンする可能性があるため）、前述の捕捉する例外の条件 c （正常なフローに引き戻す必要がある場合）に記述されているように、正常なフローに引き戻すようなことは、致命的な問題を隠蔽することになるため絶対にできない。
　このように、起こりうる全ての例外に対処法を決定することは困難であり、また、それら全てに同じ処理を適用できるものでもない。そのため、catch (Exception ex) という catch 句の記述は禁止する。以下に例を示す。

5. Disposeメソッド
  .NET Framework のガベージコレクタ4はマネージリソースに対する解放処理を自動で行う。しかし、アンマネージリソースに対しては明示的にそのリソースに対する参照が破棄されたことを通知しなければ解放処理が行われない。本章ではアンマネージリソースの破棄を明示的に通知するための Disposeメソッドとその利用方法を示す。

5.1. マネージリソースとアンマネージリソース
  .NET Framework が提供する共通言語ランタイム上で作成、管理されオブジェクトの破棄、がガベージコレクタによって自動で行われるリソースのことをマネージリソースと呼ぶ。それに対し、OS が管理しているリソース（ファイルハンドル、ウィンドウハンドル、ミューテックスなど）のことをアンマネージリソースと呼ぶ。アンマネージリソースは .NET Framework 上で作成、管理されるオブジェクトではないため、ガベージコレクタはこのリソースの解放をサポートしていない。

5.2. ガベージコレクタの動作
  C# などの CLR上で動作する言語はマネージリソースと、アンマネージリソースをカプセル化するクラスのオブジェクトをインスタンス化し、使用する。オブジェクトがインスタンス化される際、CLR はマネージヒープと呼ばれる連続したアドレス空間に領域を確保する。ガベージコレクタはこのマネージヒープ内でオブジェクトの世代管理を行い、もっとも新しい世代に属するオブジェクトの中で、参照（ポインタ）が到達不可能になっているものからメモリ領域の自動解放を行う。
  この動作についてはアンマネージリソースをカプセル化しているオブジェクトについても同様に行われるが、ガベージコレクタはアンマネージリソースそのものの存在を認識できず、オブジェクトに対する参照が残っているためこれをカプセル化するオブジェクトについてもメモリ領域を解放できない。この結果マネージヒープにゴミがたまり、OutOfMemoryException（マネージヒープにこれ以上オブジェクトが作成できない場合に発生する例外）などの致命的な例外が発生する。
  このような事態を避けるため、FCL5内のアンマネージリソースをカプセル化している全てのクラスにはアンマネージリソースへの参照を明示的に破棄する Dispose メソッドが実装されている。

5.3. IDisposable インタフェース
  IDisposable インタフェースは前述の Dispose メソッドを定義するインタフェースであり、このメソッドを使用してアンマネージリソースへの参照を明示的に破棄することができる。すなわち、FCL 内のアンマネージリソースをカプセル化している全てのクラスはこのインタフェースを実装していることになる。
  この IDisposable インタフェースを実装するクラスをデータアクセスを例にとって使用例を以下に示す。

  上記のように、IDisposable インタフェースを実装するクラスのオブジェクトを使用する際には、例外処理の構文を用い、必ず Dispose または Close メソッドを明示的に呼び出すように実装する必要がある。このため、使用した事のないクラスを使用する際には、そのクラスが IDisposable インタフェースを実装しているかどうかを必ずチェックすること。なお、そのクラスが IDisposable インタフェースを実装していなくても親クラスが実装し、そこから派生している場合もあるので注意すること。

5.4. using ステートメント
  前述の Dispose メソッドを使用した記述パターンは、Dispose メソッドを呼び忘れたり、null チェックのし忘れによる別の例外（NullReferenceException）の発生する可能性をはらんでいたりと、コーディングミスが起こりやすい記述方法である。
　Dispose の呼び出しをより確実なものとするために C# には強制的に Dispose を呼び出させるためのステートメントが存在する。それが using ステートメントである。5.3で使用したサンプルコードを using ステートメントを使用して書き直した例を以下に示す。

  上記のように記述すると using ステートメントの（）でインスタンス化したオブジェクトはスコープを外れた瞬間に自動的に Dispose メソッドが呼び出され参照が破棄されるようになる。これは .NETFramework1.1 の段階では C# のみの機能6である。
  コンパイラは using ステートメントを発見すると自動的に Dispose を意味する IL7 命令を生成するため、実行結果は例外処理構文を使用した場合とまったく同じになる。IDisposable インタフェースを実装するクラスを使用するときには必ず using ステートメントを使用して実装を行うこと。

6メソッドの行数制限について
  メソッドは業務開発時には業務仕様に忠実に実装しようとするあまり、冗長になり、気がつくとひとつのメソッドが数百行におよび、膨大な数のローカル変数が定義され、メンテナンス性を著しく悪化させる場合が多々見受けられる。
  本コーディング規約のver1.0 では「型プレフィックスを変数名に必ず付与する」としており、これは、冗長なコードを少しでも読みやすくしようとする努力の一環ではあるが、問題の根本的な解決とはいいがたい。
  ver1.1 からは「型プレフィックスの廃止」を強制することで、冗長なメソッドの排除を目指している。メソッドは可能な限り単機能で記述し、その行数は最高でも100 行を超えないようにするべきである。どうしても100 行を超えるような記述を行う必要がある場合には、有識者に意見を求め、なるべく少ない行数でメソッドそのものの記述を行えるようにすること。
1 型プレフィックスとは string 型の変数を宣言する際に strXX などのように型名が類推できるプレフィックスである。このような記法をハンガリアン記法と呼び、一昔前のコーディングではこの記法が一般的であった。昨今のオブジェクト指向的なコーディング、デザインパターンの普及などに伴い、型プレフィックスを使用せざるを得ないほどひとつのメソッドが長くなることがほとんど無くなった。
  型プレフィックスを使用しないと可読性が悪化するような冗長なコードを記述させない意味で、本規約では使用を禁ずるものとしている。
2 WindowsForm のアプリケーションの場合、Application_ThreadException ハンドラや AppDomain.CurrentDomain_UnhandledException イベントハンドラなどがこれにあたる。
その Application および AppDomain 内で発生した未処理の例外を捕捉することができる。
ASP.NET では Page_OnError イベントハンドラがこれにあたる。
3 Common Language Runtime の略語。共通言語ランタイムと訳される。.NET Framework の基盤技術の一つで、VB6, VC6 の時代に言語ごとに必要だったランタイムを廃止し、全ての言語で共通のランタイムを使用できるようにしたもの。.NET Framework を使用して作成されたアプリケーション、dll の実行環境。この技術により、.NET Framework がインストールされているマシン上では .NET Framework を使用して作成されたアプリケーションは言語ごとに個別のランタイムをインストールすることなく動作するようになった。
4 .NETFramework が持つ自動メモリ管理システム。CLR 上で動作するアプリケーションはオブジェクトの生成、破棄によるメモリ領域の確保、解放を自動で行う。C言語やC++ などのように開発者が独自にメモリ領域の確保、解放を意識してコーディングを行う必要はない。このメモリの解放の処理を行うのがガベージコレクタである。
5 Framework Class Library の略称。.NETFramework の持つクラスライブラリのこと
6 .NET Framework2.0 以降では VB.NET にも using ステートメントが実装されている。
7 MSIL とも呼ばれる Microsoft Intermediate Language の略。中間言語とも呼ばれる。C#, VB.NET など全ての .NET 対応の言語でコンパイルされたアセンブリは、コンパイル段階では IL に変換されているに過ぎない。CLR はこの IL にコンパイルされたアセンブリをリコンパイルしてバイナリなどの実行可能な状態に変換する。つまり共通言語ランタイムは IL を実行するためのランタイムになる。
---------------

------------------------------------------------------------

---------------

------------------------------------------------------------




15


